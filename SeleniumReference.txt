Selenium
reference: https://www.guru99.com/first-webdriver-script.html
just some tiny arrows → → → → →

Locating by DOM (Document Object Model):
	Will be uisng developer options in Chrome [right click → "Inspect"]
	can also use Firebug and XPath
	XPath:
		language used when locating XML nodes. Since HTML can be thought of as an implmentation of XML, we can also use XPath in locating HTML elements
		Advantages: it can access almost any element, even those without class, name, or id attributes
		Disadvantages: It is the most complicated method of identifying elementsbecause of too many different rules and considerations
		Firebug can automatically gernerate XPath locators. In the following example, we will access an image that cannot possibly be accessed through the methods we discussed earlier
	Four basic ways to locate an element through DOM:
		getElementById:
			It will only get one element for you
			That element bear the ID that you specified inside the parentheses of getElementById()
			document.getElementById("id of the element") : id of the element = this is the value of the ID attribute of the element to be accessed, specified inside parentheses
			Steps [inly works on chrome, need add-ons to do thi in firefox]:
				1. navigate to page and find element to get id of
				2. right click on it and select "Inspect"
				3. window that opens up has all info on that is related to that element, id should be in there
		
		getElementsByName():
			It will get a collection of elements whose names are all the same
			Each element is indexed with a number starting from 0 just like an array
			You specify which element you wish to access by putting its index number into the square brackets in getElementsByName's syntax
			Similar syntax as getElementById → document.getelementsByName("name of the elements")
			Same steps for getting name as it is for ID
			
		dom:name():
			this method will only apply if the element you are accessing is contained within a named form
			document.forms["name of the form"].elements["name of the element"]
				name of the form = the value of the name attribute of the form tag that contains the element you want to access
				name of the element = the value of the name attribute of the element you wish to access
			to find form name, follow same instructions as looking for ID, but instead look at the confining elements and "form name" should be there
		
		dom:index():
			this method applies even when the element is not within a named form because it uses the form's index and not its name
			document.forms[index of the form].elements[index of the element]
				index of the form = index number (starting at 0) of the form with respect to the whole page
				index of the element = the index number (starting at 0) of the lemenet with respect to the whole form that contains it
			same way of getting necessary info as previous ones but:
				ex. no name and id attributes, if it is the only form on the page the its index will be 0
					will need to count number fo inputs in form to get "element index"
		_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
		|							|									|								|
		|			Method			|			Target Syntax			|			Example				|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|	By ID					|	id = id_of_the_element			|		id = email				|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|	By Name			  		|	name = name_of_the_element		|		name = userName			|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|	By Name Using Filters	|	name = name_of_the_element		|		name = tripType			|
		|							|	filter = value_of_filter		|		value = oneway			|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|	By link text			|	link = link_text				|		link = REGISTER			|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|	Tag and ID				|	css = tag#id					|		css = input#email		|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|	Tag and Class			| css = tag[attribute e= valie]		|	css=input[name=;astName]	|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		| Tag, Class, Attribute		| css.tag.class[atrribute=value]	|	css = input.inputtext(binder|
		|							|									|			[tabindex = 1])		|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|


FindElement():
	takes in the By object as the parameter and returns an object of type WebElement. The By object in tyrn can be used with various locator stratefies such as ID, Name, Class Name, XPath
	WebElement elementName = driver.findElement(By.LocatorStrategy("LocatorValue"));
		Locator Strategy can be any of the followint: ID, Name, Class Name, Tag Name, Link Text, Partial Link Text, XPATH
	Locator Calue is the unique value ising whivh a web element can be indentifie. It is the reposnsibility of develo[ers and testers to make sure that web elements are uniquely identifiable using certain properties such as ID or name
		Ex.
			WebElement loginlink = driver.findElementt(By.linkText("Login"))
					
	command syntax:
		List<WebElement> elementName = driver.findElements(By.LocatorStrategy("LocatorValue"));
		ex. List <WebElement> listOfElement = driver.findElements(By.xpath("//div"));
		
		_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
		|									|									|
		|			Find Element			|			Find Element			|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|Returns the first most web element	|Retrurns a list of web elements	|
		|if there are multiple web elements	|									|
		|found with the same locator		|									|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|Throws exception NoSuchElementExce-|Returns an empty list it there are |
		|ption if there are no elements 	|no web elements matching the 		|
		|matching the locator strategy		|locator strategy					|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|It will only find one web element	|It will find a collection of 		|
		|									|elements whose match the locator	|
		|									|strategy							|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		|Not applicable						|Each Web element is indexed with a |
		|									|number starting from 0 just like an|
		|									|array								|
		|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|
		
	
		
	get(): 	
		atomatically opens a new browser window and fetches the page that you specify inside the parentheses
		parameter must be a String object

	getTitle():	
		needs no parameters
		fetches the title of the current page
		leading and trailing of white space are trimmed
		returns a null string if the page has no title
				
	getPageSource():
		needs no parameters
		returns the source code of the the page as a string value
		
	getCurrentUrl():
		needs no parameters
		fetches the string representing the current URL that the browser is looking at
		
	getText():
		fetches the inner text of the element that you specify
		
Navigate commands: allow you to refresh, go-into, and switch back and forth between different web pages
	navigate().to():
		automatically opens a new browser window and fetches the page that you specify inside the parentheses
		essentially the same as get()
	
	navigate().refresh():
		needs no parameters
		refreshes the current page
		
	navigate().back():
		needs no parameters
		takes you back by one page on the browser's history
		
	navigate().forward():
		needs no parameters
		takes you forward by one page on the browser's history
		
Closing and Quitting Browser Windows:
	close():
		needs no parameters
		it closes only the browser window that WebDriver is currently controlling
	
	quit():
		needs no parameters
		it closes all windows that WebDriver has opened
		
Waits: there are two kinds of waits
	Implicit Wait
		used to set the default waiting time throughout the program
		usually declared in the stantiation part of the code
		will only need to import one package → import.util.concurrent.TimeUnit;
		on the instation part of code → driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
				this means that you are setting 10 seconds as your default wait time
				"10" and "SECONDS" can be changed to any int and time unit
	
	Explicit Wait
		used to set the waiting time for a particular instance only
		are done using the WebDriverWait and ExpectedCondition classes
		in the example: wait up to 10 seconds for an element whose id is "username" to become visible before proceeding to the next command
			import necessary packages → import org.openqa.selenium.support.ui.ExpectedCondition;
										import org.openqa.selenium.support.ui.WebDriverWait;
			Declare a WebDriverWait variable → WebDriverWait myWaitVar = new WebDriverWait(driver, 10);
			Use myWaitVar with ExpectedConditions on portions where you need the explicit wait to occur → myWaitVar.until(ExpectedCondiitions.visibilityOfElementLocated(By.id("username")));
																										  driver.findElement(By.id("username")).sendKeys("tutorial");

Conditions: following methods are used in conditional and looping operations
	isEnabled():
		when you want to verify whether a certian element is enabled or not before executing a command
		ex.
			WebElement txtbox_username = driver.findElement(By.id."username"));
			if(txtbox_username.isEnabled()) {
				txtbox_username.sendKeys("tutorial");
			}
			
	isDisplayed():
		when you want to verify whether a certian element is displayed or not before executing a command
		ex.
			do {
				//do something here
			} while (driver.findElement(By.id("username")).isDisplayed());
			
	isSelected():
		when you want to verify whether a certian check box, radio button, or option in a drop-down box is selected. It does not work on other elements
		ex. 
			//"one-way" and "two-way" are radio buttons
			if (driver.findElement(By.id("one-way")).isSelected()) {
					driver.findElement(By.id("two-way"))click();
			}
			
Using ExpectedConditions:
	The ExpectedConditions class offers a wider set of conditions that you can use in conjunction with WebDriverWait's until() method
	
	alertIsPresent():
		waits until an alert box is displayed
		ex. 
			if (myWaitVar.until(ExpectedCondition.alertIsPresent()) != null) {
				System.out.println("alert is present!");
			}
	
	elementToBeClickable():
		waits until an element is visisble and, at the same time enabled
		example will wait until element with id="username" becomes visible and enabled first before assigning that element as a WebElement variable named "txtUserName"
		ex.
			WebElement txtUserName = myWaitVar.until(ExpectedConditions.elementToBeClickable(By.id("username")));
	
	frameToBeAvailiableAndSwitchToIt():
		waits until the given frame is already availiable, and then automatically switches to it
		ex.
			This will automatically switch to the "viewframe" once it becomes availiable
			myWaitVar.until(ExpectedConditions.framsToBeAvailiableAndSwitchToIt("viewIFRAME"));

Catching Exceptions:
	when usingisEnabled(), isDisplayed(), and isSelected(), WebDriver assumes that the element already exists on the page.
	Else, it will throw a NoSuchElementException.
	To avoid this, use a try-catch block so that the program will not be interrupted
	
	ex.
		WebElement txtbox_username = driver.findelement(By.id("username"));
		try {
			if(txtbox_username.isEnabled()) {
				txtbox_username.sendKeys("tutorial");
			}
		}
		
		catch (NoSuchElementException nsee) {
			System.out.println(nsee.toSrting());
		}
		
	If you use explicit waits, the type od excpetion that you should catch is the "TimeoutException"
		WebDriverWait myWaitVar = new WebDriverWait(driver, 3);
		try {
			myWaitVar.until(ExpectedConditions.visiblityOfElementLocated(By.id("username")));
			driver.findElement(By.id("username")).sendKeys("tutorial");
		} catch (TimeoutException toe) {
			System.out.println(toe.toString());
		}
		